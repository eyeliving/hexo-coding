---
title: JavaScript作用域、以及数据类型
description: JS基本数据类型的变量存放的是基本类型数据的实际值；而引用数据类型的变量保存对它的引用，即指针。  说白了就是：**基本数据类型传的是数值，引用类型传的是变量堆内存的地址**  这句在下边最后的几个例子当中尤为重要。
keywords: JavaScript作用域，JavaScript数据类型，引用类型
date: 2017-01-23 11:00
tags: javascript
---
> javascript作用域

js中的变量分为两种类型：

1. 基本数据类型
2. 引用数据类型

JS基本数据类型的变量存放的是基本类型数据的实际值；而引用数据类型的变量保存对它的引用，即指针。

说白了就是：**基本数据类型传的是数值，引用类型传的是变量堆内存的地址**

这句在下边最后的几个例子当中尤为重要。

JS基本数据类型：null undefined number boolean

string比较特殊

引用数据类型：function object array



```javascript
/*
    * 1.全局变量与局部变量
    * 外层变量可以在内层调用（全局），内层变量不能在外层调用（局部）
    * */

    var a = 1;
    (function () {
        // 外部变量可以在内部调用
        alert(a);
    })();

    function test() {
        // 内部变量不能在外部调用
        var a = 2;
    }
    alert(a);   // 报错

    /*
    * 下面举个例子：
    * 函数调用只是回到函数定义的地方，调用一下函数
    * 这里在bbb函数中，调用aaa函数，
    * 这时的aaa函数并不是被放入bbb函数中，而是在原定义的地方
    * 这是的aaa中没有变量a，所以去访问全局变量中的a
    * */

    var a = 10;
    function aaa() {
        alert(a);
    }
    function bbb() {
        var a = 20;
        aaa();
    }
    bbb();  // 10






    /*
    * 2.当var不加的时候，会自动变成全局变量
    * 在全局环境中，不加var和加var效果一样，都是全局变量
    * 在局域环境中，加var会被定义为局部变量，不加var会被定义为全局变量
    * */

    function test() {
        var a = 10; // 外部访问不到
        b = 10;     // 相当于全局变量
        // 上面相当于：var a = b = 10;
    }
    test();
    alert(b);   // 10
    alert(a);   // 报错



    /*
    * 3.变量查找按照就近原则去查找
    * var定义的变量，当就近查找没有找到就去外层查找
    * */


    var a = 10;
    (function() {
        var a = 20;
        // a在匿名函数中var定义了，所以找到为20
        alert(a);   // 20
    })();

    var a = 10;
    (function() {
        a = 20;   // 相当于全局变量，将外部的var a = 20;
        // 在匿名函数中没有找到var定义的a，然后去外层去查找
        // 外部查找到了，var a = 10 = 20;
        alert(a);   // 20
    })();

    var a = 10;
    (function() {
        // 在匿名函数中没有找到var定义的a，然后去外层去查找
        // 外部查找到了，var a = 10
        alert(a);   // 10
        a = 20;
    })();

    var a = 10;
    (function() {
        // 在匿名函数中找到var定义的a，
        // 这里的var a = 20,存在变量提升,
        // 在执行alert(a)之前，变量提示有var a;
        // 但是a没有值，所有返回undefined
        alert(a);   // undefined
        var a = 20;

        // 在变量提升的情况下，相当于下面：
        // var a;
        // alert(a);
        // a = 20;
    })();



    var a = 10;
    (function() {
        // 执行bbb,bbb中的a=20,但是与匿名函数和全局变量a无关
        bbb();
        // 在匿名函数中查找var定义的a,发现没有
        // 继续在外层中查找，发现了 var a = 10;
        alert(a);   // 10
        function bbb() {
            var a = 20;
        }
    })();


    var a = 10;
    (function() {
        bbb();
        // 在匿名函数中查找var定义的a,发现没有
        // 继续在外层中查找，发现了 var a = 10 = 20;
        alert(a);   // 20
        function bbb() {
            // 没有var定义，所有为全局变量，外面的全局变量 var a = 10 = 20;
            a = 20;
        }
    })();


    /*
    * 当参数与局部变量重名时，优先级等同
    * */

    var a = 10;
    (function (a) {
        // 这里的参数a是基本数据类型，按值传参的
        // 参数a相当于在匿名函数内部重新定义了一个a，
        // 且与外层的a不相关
        a += 3;
    })(a);
    alert(a);   // 10

    var a = [1,2,3];
    (function (a) {
        // 这里的参数a是引用类型，按引用传参的
        // 参数a相当于在匿名函数内部重新定义了一个a，
        // 但是这个a是外层a的一个别名，它们引用了同一个地址
        // 所以内部a添加值，外部a可以访问到
        a.push(4);
    })(a);
    alert(a);   // [1,2,3,4]


    var a = [1,2,3];
    (function (a) {
        // 这里的参数a是引用类型，按引用传参的
        // 参数a相当于在匿名函数内部重新定义了一个a，
        // 但是这个a是外层a的一个别名，它们引用了同一个地址
        // 所以内部a添加值，外部a可以访问到

        // 但是，这里的a又重新赋值了新的数组，断开了与外层的关系
        a = [1,2,3,4];
    })(a);
    alert(a);   // [1,2,3]
```
